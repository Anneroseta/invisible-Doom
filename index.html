```html
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DOOM: Right Hand & Jump</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            margin: 0;
            background-color: #050505;
            color: #eee;
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 800px;
            height: 600px;
            box-shadow: 0 0 30px rgba(0,0,0,0.9);
            border: 2px solid #333;
            background: #000;
            cursor: crosshair;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 80px;
            background: linear-gradient(to bottom, #3a3a3a, #222);
            border-top: 4px solid #555;
            display: flex;
            justify-content: space-around;
            align-items: center;
            z-index: 10;
            box-shadow: inset 0 10px 20px rgba(0,0,0,0.5);
        }

        .stat-box {
            text-align: center;
            width: 120px;
        }

        .stat-label {
            font-size: 10px;
            color: #aaa;
            margin-bottom: 5px;
            letter-spacing: 1px;
        }

        .stat-value {
            font-size: 28px;
            color: #b30000;
            text-shadow: 2px 2px 0 #000;
        }

        #face-container {
            width: 64px;
            height: 64px;
            background-color: #111;
            border: 2px solid #555;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 40px;
            box-shadow: inset 0 0 10px #000;
        }

        /* CRT Effect */
        #crt-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.15) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 3px, 4px 100%;
            pointer-events: none;
            z-index: 20;
            box-shadow: inset 0 0 50px rgba(0,0,0,0.7);
        }

        #message {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff3333;
            font-size: 40px;
            text-align: center;
            display: none;
            z-index: 30;
            text-shadow: 4px 4px 0 #000;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border: 2px solid #555;
        }
        
        #controls-hint {
            position: absolute;
            top: 10px;
            left: 10px;
            color: rgba(255,255,255,0.5);
            font-size: 10px;
            z-index: 25;
            pointer-events: none;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="640" height="480"></canvas>
    <div id="crt-overlay"></div>
    
    <div id="controls-hint">WASD - –î–≤–∏–∂–µ–Ω–∏–µ | –õ–ö–ú - –°—Ç—Ä–µ–ª—å–±–∞ | –ü–†–û–ë–ï–õ - –ü—Ä—ã–∂–æ–∫</div>

    <div id="ui-layer">
        <div class="stat-box">
            <div class="stat-label">–ó–î–û–†–û–í–¨–ï</div>
            <div class="stat-value" id="health-val">100%</div>
        </div>
        <div id="face-container">üò†</div>
        <div class="stat-box">
            <div class="stat-label">–ü–ê–¢–†–û–ù–´</div>
            <div class="stat-value" id="ammo-val">50</div>
        </div>
        <div class="stat-box">
            <div class="stat-label">–°–ß–ï–¢</div>
            <div class="stat-value" id="score-val">0</div>
        </div>
    </div>

    <div id="message">–í–´ –ü–û–ì–ò–ë–õ–ò<br><span style="font-size:16px; color:#aaa; margin-top:10px; display:block">–ù–∞–∂–º–∏ R –¥–ª—è —Ä–µ—Å—Ç–∞—Ä—Ç–∞</span></div>
</div>

<script>
/**
 * DOOM-STYLE ENGINE V2
 * Features: Right-handed weapon, Jumping, Improved Enemies, Mouse Shooting
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
const uiHealth = document.getElementById('health-val');
const uiAmmo = document.getElementById('ammo-val');
const uiScore = document.getElementById('score-val');
const uiFace = document.getElementById('face-container');
const msgDiv = document.getElementById('message');

// --- CONFIG ---
const SCREEN_WIDTH = 640;
const SCREEN_HEIGHT = 480;
const FOV = Math.PI / 3;
const BLOCK_SIZE = 64;
const MAX_DEPTH = 24; 
const MOVEMENT_SPEED = 3.5;
const ROTATION_SPEED = 0.06;
const JUMP_FORCE = 7.0;
const GRAVITY = 0.4;
const PLAYER_HEIGHT = 30; // Camera height from floor

// --- STATE ---
let gameOver = false;
let score = 0;

const player = {
    x: BLOCK_SIZE * 3.5,
    y: BLOCK_SIZE * 3.5,
    z: 0, // Vertical position (for jumping)
    velZ: 0,
    dir: 0,
    health: 100,
    ammo: 50,
    weaponFrame: 0, 
    weaponTimer: 0,
    isGrounded: true
};

// Map: 1=Wall, 0=Empty
const map = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1],
    [1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1],
    [1,0,0,1,0,0,0,0,0,1,1,1,1,1,0,1,0,1,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,0,0,1],
    [1,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
];

let enemies = [];

class Enemy {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.alive = true;
        this.hp = 3;
        this.state = 'idle';
        this.hitFlash = 0; // For visual feedback when shot
    }

    update() {
        if (!this.alive) return;
        if (this.hitFlash > 0) this.hitFlash--;

        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const dist = Math.sqrt(dx*dx + dy*dy);

        if (dist < BLOCK_SIZE * 10) {
            this.state = 'chase';
            const moveX = (dx / dist) * 1.2; // Enemy speed
            const moveY = (dy / dist) * 1.2;

            // Simple collision
            if (map[Math.floor(this.y / BLOCK_SIZE)][Math.floor((this.x + moveX) / BLOCK_SIZE)] === 0) this.x += moveX;
            if (map[Math.floor((this.y + moveY) / BLOCK_SIZE)][Math.floor(this.x / BLOCK_SIZE)] === 0) this.y += moveY;
        }

        if (dist < BLOCK_SIZE * 0.8) {
            player.health -= 0.5;
            updateUI();
            if (player.health <= 0) endGame();
        }
    }
}

function spawnEnemies() {
    enemies = [];
    enemies.push(new Enemy(10 * BLOCK_SIZE, 10 * BLOCK_SIZE));
    enemies.push(new Enemy(15 * BLOCK_SIZE, 5 * BLOCK_SIZE));
    enemies.push(new Enemy(5 * BLOCK_SIZE, 15 * BLOCK_SIZE));
    enemies.push(new Enemy(18 * BLOCK_SIZE, 18 * BLOCK_SIZE));
    enemies.push(new Enemy(12 * BLOCK_SIZE, 14 * BLOCK_SIZE));
}

// --- INPUT ---
const keys = {};
window.addEventListener('keydown', e => {
    keys[e.code] = true;
    if (e.code === 'Space') doJump();
    if (e.code === 'KeyR' && gameOver) restartGame();
});
window.addEventListener('keyup', e => keys[e.code] = false);

// Mouse Shooting
canvas.addEventListener('mousedown', (e) => {
    if (e.button === 0 && !gameOver) shoot(); // Left Click
});

// --- LOGIC ---

function doJump() {
    if (player.isGrounded) {
        player.velZ = JUMP_FORCE;
        player.isGrounded = false;
    }
}

function update() {
    if (gameOver) return;

    // Rotation
    if (keys['ArrowLeft'] || keys['KeyA']) player.dir -= ROTATION_SPEED;
    if (keys['ArrowRight'] || keys['KeyD']) player.dir += ROTATION_SPEED;

    // Movement
    let moveStep = 0;
    if (keys['ArrowUp'] || keys['KeyW']) moveStep = MOVEMENT_SPEED;
    if (keys['ArrowDown'] || keys['KeyS']) moveStep = -MOVEMENT_SPEED;

    let strafeStep = 0;
    if (keys['KeyQ']) strafeStep = -MOVEMENT_SPEED;
    if (keys['KeyE']) strafeStep = MOVEMENT_SPEED;

    const cos = Math.cos(player.dir);
    const sin = Math.sin(player.dir);

    const newX = player.x + cos * moveStep - sin * strafeStep;
    const newY = player.y + sin * moveStep + cos * strafeStep;

    // Collision
    if (map[Math.floor(player.y / BLOCK_SIZE)][Math.floor(newX / BLOCK_SIZE)] === 0) player.x = newX;
    if (map[Math.floor(newY / BLOCK_SIZE)][Math.floor(player.x / BLOCK_SIZE)] === 0) player.y = newY;

    // Jump Physics
    player.z += player.velZ;
    player.velZ -= GRAVITY;

    if (player.z <= 0) {
        player.z = 0;
        player.velZ = 0;
        player.isGrounded = true;
    }

    // Weapon Animation
    if (player.weaponTimer > 0) {
        player.weaponTimer--;
        if (player.weaponTimer === 0) player.weaponFrame = 0;
    }

    enemies.forEach(e => e.update());
}

function shoot() {
    if (player.weaponTimer > 0 || player.ammo <= 0) return;
    
    player.ammo--;
    player.weaponFrame = 1; 
    player.weaponTimer = 12; 
    updateUI();

    let hitEnemy = null;
    let minDist = 10000;

    enemies.forEach(e => {
        if (!e.alive) return;
        const dx = e.x - player.x;
        const dy = e.y - player.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        let angleToEnemy = Math.atan2(dy, dx) - player.dir;
        while (angleToEnemy < -Math.PI) angleToEnemy += 2*Math.PI;
        while (angleToEnemy > Math.PI) angleToEnemy -= 2*Math.PI;

        if (Math.abs(angleToEnemy) < 0.25 && dist < minDist) {
             if (!isWallBetween(player.x, player.y, e.x, e.y)) {
                minDist = dist;
                hitEnemy = e;
            }
        }
    });

    if (hitEnemy) {
        hitEnemy.hp--;
        hitEnemy.hitFlash = 5;
        if (hitEnemy.hp <= 0) {
            hitEnemy.alive = false;
            score += 100;
            updateUI();
        }
    }
}

function isWallBetween(x1, y1, x2, y2) {
    const dist = Math.sqrt((x2-x1)**2 + (y2-y1)**2);
    const steps = dist / (BLOCK_SIZE/2);
    for(let i=0; i<steps; i++) {
        const cx = x1 + (x2-x1)*(i/steps);
        const cy = y1 + (y2-y1)*(i/steps);
        if (map[Math.floor(cy/BLOCK_SIZE)][Math.floor(cx/BLOCK_SIZE)] === 1) return true;
    }
    return false;
}

// --- RENDER ---
let zBuffer = new Array(SCREEN_WIDTH).fill(0);

function draw() {
    // Clear
    ctx.fillStyle = '#1a1a2e'; // Dark Blue Ceiling
    ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT / 2);
    ctx.fillStyle = '#2e1a1a'; // Dark Red Floor
    ctx.fillRect(0, SCREEN_HEIGHT / 2, SCREEN_WIDTH, SCREEN_HEIGHT / 2);

    // Raycasting Walls
    for (let x = 0; x < SCREEN_WIDTH; x+=2) {
        const rayAngle = (player.dir - FOV / 2.0) + (x / SCREEN_WIDTH) * FOV;
        const eyeX = Math.cos(rayAngle);
        const eyeY = Math.sin(rayAngle);

        let mapX = Math.floor(player.x / BLOCK_SIZE);
        let mapY = Math.floor(player.y / BLOCK_SIZE);
        
        let deltaDistX = Math.abs(1 / eyeX);
        let deltaDistY = Math.abs(1 / eyeY);
        
        let stepX, stepY;
        let sideDistX, sideDistY;
        let side = 0;

        if (eyeX < 0) { stepX = -1; sideDistX = (player.x / BLOCK_SIZE - mapX) * deltaDistX; }
        else { stepX = 1; sideDistX = (mapX + 1.0 - player.x / BLOCK_SIZE) * deltaDistX; }
        
        if (eyeY < 0) { stepY = -1; sideDistY = (player.y / BLOCK_SIZE - mapY) * deltaDistY; }
        else { stepY = 1; sideDistY = (mapY + 1.0 - player.y / BLOCK_SIZE) * deltaDistY; }

        let hitWall = false;
        let distToWall = 0;

        while (!hitWall && distToWall < MAX_DEPTH) {
            if (sideDistX < sideDistY) { sideDistX += deltaDistX; mapX += stepX; side = 0; }
            else { sideDistY += deltaDistY; mapY += stepY; side = 1; }
            
            if (mapX >= 0 && mapX < 24 && mapY >= 0 && mapY < 22) {
                if (map[mapY][mapX] > 0) hitWall = true;
            } else { hitWall = true; }
        }

        if (side === 0) distToWall = (mapX - player.x / BLOCK_SIZE + (1 - stepX) / 2) / eyeX;
        else           distToWall = (mapY - player.y / BLOCK_SIZE + (1 - stepY) / 2) / eyeY;

        zBuffer[x] = distToWall;
        zBuffer[x+1] = distToWall;

        // Wall Drawing with Jump Offset
        // Base wall height calculation
        const lineHeight = Math.floor(SCREEN_HEIGHT / distToWall);
        
        // Apply Player Z (Jump) to draw start/end
        // In Doom, jumping moves the camera up, so the horizon moves down relative to screen center
        const jumpOffset = player.z * (SCREEN_HEIGHT / distToWall) / BLOCK_SIZE; 
        
        let drawStart = -lineHeight / 2 + SCREEN_HEIGHT / 2 + jumpOffset;
        let drawEnd = lineHeight / 2 + SCREEN_HEIGHT / 2 + jumpOffset;

        // Colors
        let color = side === 1 ? '#555' : '#777';
        if (distToWall > 10) {
             // Simple fog
             const fog = Math.min((distToWall - 10) / 10, 0.8);
             ctx.fillStyle = `rgb(${55 * (1-fog)}, ${55 * (1-fog)}, ${55 * (1-fog)})`;
        } else {
            ctx.fillStyle = color;
        }
        
        ctx.fillRect(x, drawStart, 2, drawEnd - drawStart);
    }

    // Draw Enemies (Sprites)
    const sortedEnemies = [...enemies].map(e => {
        return { ...e, dist: Math.sqrt((player.x - e.x)**2 + (player.y - e.y)**2) };
    }).sort((a, b) => b.dist - a.dist);

    sortedEnemies.forEach(e => {
        if (!e.alive) return;

        const dx = e.x - player.x;
        const dy = e.y - player.y;

        let spriteAngle = Math.atan2(dy, dx) - player.dir;
        while (spriteAngle < -Math.PI) spriteAngle += 2*Math.PI;
        while (spriteAngle > Math.PI) spriteAngle -= 2*Math.PI;

        if (Math.abs(spriteAngle) > FOV / 1.5) return;

        const spriteScreenX = (0.5 * (spriteAngle / (FOV / 2)) + 0.5) * SCREEN_WIDTH;
        const spriteHeight = (SCREEN_HEIGHT / e.dist) * BLOCK_SIZE * 1.2; 
        const spriteWidth = spriteHeight * 0.8;
        
        // Apply Jump Offset to Sprite
        const spriteJumpOffset = player.z * (SCREEN_HEIGHT / e.dist) / BLOCK_SIZE;
        const spriteTop = (SCREEN_HEIGHT - spriteHeight) / 2 + spriteJumpOffset;

        const checkIdx = Math.floor(spriteScreenX);
        if (checkIdx >= 0 && checkIdx < SCREEN_WIDTH && e.dist < zBuffer[checkIdx]) {
            drawEnemySprite(spriteScreenX, spriteTop, spriteWidth, spriteHeight, e.hitFlash);
        }
    });

    drawWeapon();
}

function drawEnemySprite(x, y, w, h, flash) {
    // Body
    ctx.fillStyle = flash > 0 ? '#fff' : '#8B4513'; // Brown
    ctx.beginPath();
    ctx.ellipse(x, y + h/2, w/2, h/2, 0, 0, Math.PI*2);
    ctx.fill();

    // Shoulders/Arms
    ctx.fillStyle = flash > 0 ? '#fff' : '#65330e';
    ctx.beginPath();
    ctx.arc(x - w/3, y + h/3, w/4, 0, Math.PI*2);
    ctx.arc(x + w/3, y + h/3, w/4, 0, Math.PI*2);
    ctx.fill();

    // Eyes (Glowing)
    ctx.fillStyle = '#ff0';
    ctx.shadowBlur = 10;
    ctx.shadowColor = '#ff0';
    ctx.beginPath();
    ctx.arc(x - w/5, y + h/3, w/10, 0, Math.PI*2);
    ctx.arc(x + w/5, y + h/3, w/10, 0, Math.PI*2);
    ctx.fill();
    ctx.shadowBlur = 0;

    // Mouth
    ctx.fillStyle = '#000';
    ctx.fillRect(x - w/6, y + h/1.5, w/3, h/10);
}

function drawWeapon() {
    // Weapon Bobbing
    const isMoving = (keys['KeyW'] || keys['KeyS'] || keys['KeyA'] || keys['KeyD'] || keys['ArrowUp'] || keys['ArrowDown']);
    const bobX = Math.cos(Date.now() / 150) * (isMoving ? 8 : 0);
    const bobY = Math.abs(Math.sin(Date.now() / 150)) * (isMoving ? 8 : 0);
    
    // Jump recoil effect on weapon
    const jumpRecoil = player.z * 2; 

    // Position: RIGHT HAND (offset from center)
    const gunBaseX = SCREEN_WIDTH * 0.65; 
    const gunBaseY = SCREEN_HEIGHT;

    const gunX = gunBaseX + bobX;
    const gunY = gunBaseY - (player.weaponFrame === 1 ? 50 : 0) + bobY + jumpRecoil;

    // Draw Shotgun
    // Barrel Left
    ctx.fillStyle = '#222';
    ctx.fillRect(gunX - 40, gunY - 120, 35, 150);
    // Barrel Right
    ctx.fillStyle = '#333';
    ctx.fillRect(gunX - 10, gunY - 120, 35, 150);
    
    // Hand holding it
    ctx.fillStyle = '#dcb'; // Skin tone
    ctx.beginPath();
    ctx.arc(gunX + 10, gunY + 20, 30, 0, Math.PI, true);
    ctx.fill();

    // Muzzle Flash
    if (player.weaponFrame === 1) {
        ctx.fillStyle = '#ffaa00';
        ctx.beginPath();
        ctx.arc(gunX - 25, gunY - 140, 40 + Math.random()*20, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(gunX - 25, gunY - 140, 20, 0, Math.PI*2);
        ctx.fill();
    }
}

function updateUI() {
    uiHealth.innerText = Math.floor(player.health) + '%';
    uiAmmo.innerText = player.ammo;
    uiScore.innerText = score;
    
    if (player.health > 75) uiFace.innerText = 'üò†';
    else if (player.health > 25) uiFace.innerText = 'üò¨';
    else uiFace.innerText = 'ü§ï';
    
    if (player.isGrounded) uiFace.style.transform = 'scale(1)';
    else uiFace.style.transform = 'scale(1.1)'; // Face stretches when jumping
}

function endGame() {
    gameOver = true;
    msgDiv.style.display = 'block';
}

function restartGame() {
    player.x = BLOCK_SIZE * 3.5;
    player.y = BLOCK_SIZE * 3.5;
    player.z = 0;
    player.velZ = 0;
    player.health = 100;
    player.ammo = 50;
    score = 0;
    gameOver = false;
    msgDiv.style.display = 'none';
    spawnEnemies();
    updateUI();
}

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

spawnEnemies();
loop();

</script>
</body>
</html>
```
